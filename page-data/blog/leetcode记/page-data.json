{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/leetcode记/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"4ee34868-bc30-5071-bb59-438a5e9c0361","excerpt":"This is a personal answers of leetcode problem. My aim is to find the fast way to solve the problems by python. In some cases, the time or …","html":"<p>This is a personal answers of leetcode problem. My aim is to find the fast way to solve the problems by python. In some cases, the time or space complexity may be sacrificed. All the problems sorted by AC rate.</p>\n<h1>No.292 <a href=\"https://leetcode.com/problems/nim-game/\">Nim game</a></h1>\n<blockquote>\n<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.\nBoth of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.\nFor example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>\n</blockquote>\n<p>The introduction leaks the most important hint that if there are 4 stones left and you are the first, you will never win. So, our aim is to let the opponent to face this situation. Obviously, if you are the first and can not make the number of left stones as 4n, you must lose. This is a math problem and code is nonsence.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def canWinNim(self, n):\n        &quot;&quot;&quot;\n        :type n: int\n        :rtype: bool\n        &quot;&quot;&quot;\n        if n%4 == 0:\n            return False\n        else:\n            return True</code></pre></div>\n<h1>No.136 <a href=\"https://leetcode.com/problems/single-number/\">Single Number</a></h1>\n<blockquote>\n<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>\n</blockquote>\n<p>Very common problem, set function is a very simple solution of these kind of problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def singleNumber(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: int\n        &quot;&quot;&quot;\n        return sum(set(nums))*2-sum(nums)</code></pre></div>\n<h1>No.258 <a href=\"https://leetcode.com/problems/add-digits/\">Add Digits</a></h1>\n<blockquote>\n<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>\n</blockquote>\n<p>Python flexible str and list function will solve the problem　concisely.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def addDigits(self, num):\n        &quot;&quot;&quot;\n        :type num: int\n        :rtype: int\n        &quot;&quot;&quot;\n        if len(list(str(num))) == 1:\n            return sum(map(int,list(str(num))))\n        else:\n            return self.addDigits(sum(map(int,list(str(num)))))</code></pre></div>\n<h1>No.104 <a href=\"https://leetcode.com/problems/maximum-depth-of-binary-tree/\">Maximun Depth of Binary Tree</a></h1>\n<blockquote>\n<p>Given a binary tree, find its maximum depth.</p>\n</blockquote>\n<blockquote>\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n</blockquote>\n<p>Basic algorithm problem. Recursion is the simplist solution.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def maxDepth(self, root):\n        &quot;&quot;&quot;\n        :type root: TreeNode\n        :rtype: int\n        &quot;&quot;&quot;\n        if root == None:\n            return 0\n        else:\n            return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1</code></pre></div>\n<h1>No.226 <a href=\"https://leetcode.com/problems/invert-binary-tree/\">Invert Binary Tree</a></h1>\n<blockquote>\n<p>Invert a binary tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 4</code></pre></div>\n<p>   /   <br>\n2     7\n/ \\   / <br>\n1   3 6   9</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&gt; to\n&gt; ```\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1</code></pre></div>\n<p>Tuple equation is the simplist way to solve switch problems.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def invertTree(self, root):\n        &quot;&quot;&quot;\n        :type root: TreeNode\n        :rtype: TreeNode\n        &quot;&quot;&quot;\n        if root != None:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n        return root</code></pre></div>\n<h1>No.237 <a href=\"https://leetcode.com/problems/delete-node-in-a-linked-list/\">Delete Node in a Linked List</a></h1>\n<blockquote>\n<p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>\n</blockquote>\n<blockquote>\n<p>Supposed the linked list is <code class=\"language-text\">1 -&gt; 2 -&gt; 3 -&gt; 4</code> and you are given the third node with value 3, the linked list should become <code class=\"language-text\">1 -&gt; 2 -&gt; 4</code> after calling your function.</p>\n</blockquote>\n<p>Unlike normal link node problems, the head node is unavailable. So we can not solve the front node’s next link. But this problem does not limit the node value such that we can replace the value of node by next node as a bypass solution.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def deleteNode(self, node):\n        &quot;&quot;&quot;\n        :type node: ListNode\n        :rtype: void Do not return anything, modify node in-place instead.\n        &quot;&quot;&quot;\n\n        node.val = node.next.val\n        node.next = node.next.next</code></pre></div>\n<h1>No.283 <a href=\"https://leetcode.com/problems/move-zeroes/\">Move Zeros</a></h1>\n<blockquote>\n<p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>\n</blockquote>\n<blockquote>\n<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>\n</blockquote>\n<p>A simple solution is obvious and speed is not the best in this solution.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def moveZeroes(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        &quot;&quot;&quot;\n        n = nums.count(0)\n        for i in range(n):\n            nums.remove(0)\n        nums.extend([0]*n)</code></pre></div>\n<p>The normal fast way is use two pointers. One points and one points last to find non-zero position to switch.</p>\n<h1>No.100 <a href=\"https://leetcode.com/problems/same-tree/\">Same Tree</a></h1>\n<blockquote>\n<p>Given two binary trees, write a function to check if they are equal or not.</p>\n</blockquote>\n<blockquote>\n<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>\n</blockquote>\n<p>A simple recursion problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def isSameTree(self, p, q):\n        &quot;&quot;&quot;\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        &quot;&quot;&quot;\n        if p == None and q != None:\n            return False\n        elif p != None and q == None:\n            return False\n        elif p == None and q == None:\n            return True\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(q.right,p.right)</code></pre></div>\n<h1>No.260 <a href=\"https://leetcode.com/problems/single-number-iii/\">Single Number 3</a></h1>\n<blockquote>\n<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>\n</blockquote>\n<blockquote>\n<p>For example:</p>\n</blockquote>\n<blockquote>\n<p>Given <code class=\"language-text\">nums = [1, 2, 1, 3, 2, 5]</code>, return <code class=\"language-text\">[3, 5]</code>.</p>\n</blockquote>\n<p>A common way is establish a dict to count so that the time complexity could be liinear runtime. But obviously the number set is big and the space sonsumption is not good. Anyway, it is fast solution~</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def singleNumber(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: List[int]\n        &quot;&quot;&quot;\n        d = dict(zip(set(nums),[0]*len(set(nums))))\n        for i in nums:\n            if i in d:\n                d[i] += 1\n        result = []\n        for i in d:\n            if d[i] == 1:\n                result.append(i)\n        return result</code></pre></div>\n<h1>No.238 <a href=\"https://leetcode.com/problems/product-of-array-except-self/\">Product of Array Except Self</a></h1>\n<blockquote>\n<p>Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>\n</blockquote>\n<blockquote>\n<p>Solve it <strong>without division</strong> and in O(n).</p>\n</blockquote>\n<blockquote>\n<p>For example, given [1,2,3,4], return [24,12,8,6].</p>\n</blockquote>\n<p>In this problem, we could only use multiply operation. A concise and common idea is establsh two support list. One of them save the left result of multiplying and another save the right. For example, the original list is <code class=\"language-text\">[1,2,3,4]</code> so the left multiplying result is [1,1,2,6] and the right is [24,12,4,1]. The time complexity is O(n) of these operation. Next procedure is obvious. Just do vector multiply and get the result.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def productExceptSelf(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: List[int]\n        &quot;&quot;&quot;\n        length = len(nums)\n        left = [1]*length\n        right = [1]*length\n        for i in range(1,length):\n            left[i] = left[i-1]*nums[i-1]\n        for i in range(1,length):\n            right[length-i-1] = right[length-i]*nums[length-i]\n        result = [x*y for x,y in zip(left,right)]\n        return result</code></pre></div>\n<h1>No.242 <a href=\"https://leetcode.com/problems/valid-anagram/\">Valid Anagram</a></h1>\n<blockquote>\n<p>Given two strings s and t, write a function to determine if t is an anagram of s.</p>\n</blockquote>\n<blockquote>\n<p>For example,\ns = “anagram”, t = “nagaram”, return true.\ns = “rat”, t = “car”, return false.</p>\n</blockquote>\n<blockquote>\n<p>Note:\nYou may assume the string contains only lowercase alphabets.</p>\n</blockquote>\n<p>Using python power inside function is a concise solution.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def isAnagram(self, s, t):\n        &quot;&quot;&quot;\n        :type s: str\n        :type t: str\n        :rtype: bool\n        &quot;&quot;&quot;\n        s1 = list(s)\n        s2 = list(t)\n        s1.sort()\n        s2.sort()\n        if &#39;&#39;.join(s1) == &#39;&#39;.join(s2):\n            return True\n        else:\n            return False</code></pre></div>\n<h1>No.171 <a href=\"https://leetcode.com/problems/excel-sheet-column-number/\">Excel Sheet Column Number</a></h1>\n<blockquote>\n<p>Related to question Excel Sheet Column Title</p>\n</blockquote>\n<blockquote>\n<p>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>\n</blockquote>\n<blockquote>\n<p>For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">The only important thing is the `ord` function.</code></pre></div>\n<p>class Solution(object):\ndef titleToNumber(self, s):\n\"\"\"\n:type s: str\n:rtype: int\n\"\"\"\nsum = 0\nfor i in s:\nsum = sum * 26 + ord(i) - 64\nreturn sum</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.217 [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)\n\n&gt; Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n\nJust use `set` and all things gone. Let us recite loudly -- **Python is almighty!**</code></pre></div>\n<p>class Solution(object):\ndef containsDuplicate(self, nums):\n\"\"\"\n:type nums: List[int]\n:rtype: bool\n\"\"\"\nreturn len(set(nums)) &#x3C; len(nums)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.169 [Majority Element](https://leetcode.com/problems/majority-element/)\n\n&gt;　Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.\n\n&gt; You may assume that the array is non-empty and the majority element always exist in the array.\n\nBecause of the condition, a straight solution is sort the list and return the middle one.</code></pre></div>\n<p>class Solution(object):\ndef majorityElement(self, nums):\n\"\"\"\n:type nums: List[int]\n:rtype: int\n\"\"\"\nnums.sort()\nreturn nums[len(nums)//2]</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.268 [Missing Number](https://leetcode.com/problems/missing-number/)\n\n&gt; Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\n\n&gt; For example,\n&gt; Given nums = [0, 1, 3] return 2.\n\nNo difficulty. Just be causious of boundary conditions.</code></pre></div>\n<p>class Solution(object):\ndef missingNumber(self, nums):\n\"\"\"\n:type nums: List[int]\n:rtype: int\n\"\"\"\nnums.sort()\nif nums[0] != 0:\nreturn 0\nelif len(nums) == 1:\nreturn 1\nfor i in range(len(nums)-1):\nif nums[i]+1 != nums[i+1]:\nreturn nums[i]+1\nreturn nums[-1]+1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.144 [Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\n\n&gt; Given a binary tree, return the preorder traversal of its nodes&#39; values.\n\nBasic algorithm.</code></pre></div>\n<p>class Solution(object):\ndef preorderTraversal(self, root):\n\"\"\"\n:type root: TreeNode\n:rtype: List[int]\n\"\"\"\nif root == None:\nreturn []\nresult = [root.val]\nif root.left != None:\nresult.extend(self.preorderTraversal(root.left))\nif root.right != None:\nresult.extend(self.preorderTraversal(root.right))\nreturn result</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Iterable version is also easy. Stack construction can solve it perfectly.\n\n# No.94 [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n&gt; Given a binary tree, return the inorder traversal of its nodes&#39; values.\n\nAlso a basic problem like the upper one.</code></pre></div>\n<p>class Solution(object):\ndef inorderTraversal(self, root):\n\"\"\"\n:type root: TreeNode\n:rtype: List[int]\n\"\"\"\nif root == None:\nreturn []\nif root.left != None:\nresult = self.inorderTraversal(root.left)\nelse:\nresult = []\nresult.append(root.val)\nif root.right != None:\nresult.extend(self.inorderTraversal(root.right))\nreturn result</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Iterable version is also simple structure of stack. Postorder one will be a little difficult which given below.\n\n# No.145 [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\n\n&gt; Given a binary tree, return the postorder traversal of its nodes&#39; values.\n\nNow the last one of basic binary tree series. Unlike the former recursion solution, following is Iterable one.\n\nIn postorder, simple stack structure can not work, so we need to add a flag to represent whether the child nodes in stack. Suppose `False` flag means child node had enter in stack and `True` flag is opposite.\n\nObviously, if we have the flag, once we pop a node from stack, if flag is `True`, we can push it back and set False, and then push its left and right child node with True. Do it loop and problem solved.</code></pre></div>\n<p>class Solution(object):\ndef postorderTraversal(self, root):\n\"\"\"\n:type root: TreeNode\n:rtype: List[int]\n\"\"\"\nq = []\nresult = []\nif not root:\nreturn []\nq.append((root,True))\nwhile q:\nx,y = q.pop()\nl = x.left\nr = x.right\nif y:\nq.append((x,False))\nif r:\nq.append((r,True))\nif l:\nq.append((l,True))\nelse:\nresult.append(x.val)\nreturn result</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.206 [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\n\n&gt; Reverse a singly linked list.\n\nEstablish a new head pointer. We could cut the old chain one by one and stick to the front of new chain.</code></pre></div>\n<p>class Solution(object):\ndef reverseList(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nif not head:\nreturn None\nelse:\nnew<em>head, p = head, head.next\nnew</em>head.next = None\nwhile p:\ntmp, p = p, p.next\nnew<em>head, tmp.next = tmp, new</em>head\nreturn new_head</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.235 [Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n&gt; Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.\n\n&gt; According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”\n&gt; ```\n        _______6______\n       /              \\\n    ___2__          ___8__\n   /      \\        /      \\\n   0      _4       7       9\n         /  \\\n         3   5</code></pre></div>\n<blockquote>\n<p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>\n</blockquote>\n<p>Like decision tree. First, if one of them is root, done. Else, if root value between them, they must divided in different chile tree, so the root is the lowest common ancestor. In other word, if the root is not the middle one, they must in the same child tree, so we can use recursion to solve.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        &quot;&quot;&quot;\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        &quot;&quot;&quot;\n        if not root:\n            return None\n\n        if root is p or root is q:\n            return root\n\n        if p.val &lt; root.val &lt; q.val or q.val &lt; root.val &lt; p.val:\n            return root\n\n        if p.val &lt; root.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        else:\n            return self.lowestCommonAncestor(root.right, p, q)</code></pre></div>\n<h1>No.191 <a href=\"https://leetcode.com/problems/number-of-1-bits/\">Number of 1 Bits</a></h1>\n<blockquote>\n<p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p>\n</blockquote>\n<blockquote>\n<p>For example, the 32-bit integer ’11’ has binary representation <code class=\"language-text\">00000000000000000000000000001011</code>, so the function should return <code class=\"language-text\">3</code>.</p>\n</blockquote>\n<p>Bsic problem. We can use <code class=\"language-text\">&gt;&gt;</code> operation. <code class=\"language-text\">bin</code>　it and change to char list to solve is also good way.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def hammingWeight(self, n):\n        &quot;&quot;&quot;\n        :type n: int\n        :rtype: int\n        &quot;&quot;&quot;\n        count = 0\n        while n &gt; 0:\n            tail = n % 2\n            if tail == 1:\n                count += 1\n            n = n &gt;&gt; 1\n        return count</code></pre></div>\n<h1>No.328 <a href=\"https://leetcode.com/problems/odd-even-linked-list/\">Odd Even Linked List</a></h1>\n<blockquote>\n<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>\n</blockquote>\n<blockquote>\n<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>\n</blockquote>\n<blockquote>\n<p>Example:\nGiven <code class=\"language-text\">1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>,\nreturn <code class=\"language-text\">1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code>.</p>\n</blockquote>\n<blockquote>\n<p>Note:\nThe relative order inside both the even and odd groups should remain as it was in the input.\nThe first node is considered odd, the second node even and so on …</p>\n</blockquote>\n<p>Inplace produce more difficuty, but the algorithm is not complex.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def oddEvenList(self, head):\n        &quot;&quot;&quot;\n        :type head: ListNode\n        :rtype: ListNode\n        &quot;&quot;&quot;\n        if head:\n            odd = head\n            even_head = even = head.next\n\n            while even:\n                odd.next = even.next\n                if not odd.next:\n                    break\n\n                odd = odd.next\n                even.next = odd.next\n                even = even.next\n\n            odd.next = even_head\n        return head</code></pre></div>\n<h1>No.137 <a href=\"https://leetcode.com/problems/single-number-ii/\">Single Number 2</a></h1>\n<blockquote>\n<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>\n</blockquote>\n<blockquote>\n<p>Note:\nYour algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>\n</blockquote>\n<p>Also use <code class=\"language-text\">set</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def singleNumber(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: int\n        &quot;&quot;&quot;\n        return (sum(set(nums))*3 - sum(nums))/2</code></pre></div>\n<h1>No.96 <a href=\"https://leetcode.com/problems/unique-binary-search-trees/\">Unique Binary Search Trees</a></h1>\n<blockquote>\n<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>\n</blockquote>\n<p>Recursion is a typical solution. But it actually a mathematical problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def numTrees(self, n):\n        &quot;&quot;&quot;\n        :type n: int\n        :rtype: int\n        &quot;&quot;&quot;\n        return math.factorial(2*n)/(math.factorial(n)*math.factorial(n+1))</code></pre></div>\n<h1>No.141 <a href=\"https://leetcode.com/problems/linked-list-cycle/\">Linked List Cycle</a></h1>\n<blockquote>\n<p>Given a linked list, determine if it has a cycle in it.</p>\n</blockquote>\n<blockquote>\n<p>Follow up:\nCan you solve it without using extra space?</p>\n</blockquote>\n<p>A very interesting problem. The solution is even more amazing. We establsh two pointers, a pointer move one pace each time and another is two. If there is a cycle, they must meet again.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def hasCycle(self, head):\n        &quot;&quot;&quot;\n        :type head: ListNode\n        :rtype: bool\n        &quot;&quot;&quot;\n        try:\n            head1 = head\n            head2 = head.next\n            while not head1 is head2:\n                head1 = head1.next\n                head2 = head2.next.next\n            return True\n        except:\n            return False</code></pre></div>\n<h1>No.35 <a href=\"https://leetcode.com/problems/search-insert-position/\">Search Insert Position</a></h1>\n<blockquote>\n<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>\n</blockquote>\n<blockquote>\n<p>You may assume no duplicates in the array.</p>\n</blockquote>\n<p>An easy problem, <code class=\"language-text\">enumerate</code> is useful.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def searchInsert(self, nums, target):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        &quot;&quot;&quot;\n        for index, i in enumerate(nums):\n            if i &gt;= target:\n                return index\n        return len(nums)</code></pre></div>\n<h1>No.108 <a href=\"https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/\">Convert Sorted Array to Binary Search Tree</a></h1>\n<blockquote>\n<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>\n</blockquote>\n<p>recursion is perfect.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def sortedArrayToBST(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: TreeNode\n        &quot;&quot;&quot;\n        if not nums:\n            return None\n        if len(nums) == 1:\n            return TreeNode(nums[0])\n        m = len(nums) &gt;&gt; 1\n        root = TreeNode(nums[m])\n        root.left = self.sortedArrayToBST(nums[:m])\n        root.right = self.sortedArrayToBST(nums[m+1:])\n        return root</code></pre></div>\n<h1>No.116 <a href=\"https://leetcode.com/problems/populating-next-right-pointers-in-each-node/\">Populating Next Right Pointers in Each Node</a></h1>\n<blockquote>\n<p>Given a binary tree</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"></code></pre></div>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">struct TreeLinkNode {\n  TreeLinkNode *left;\n  TreeLinkNode *right;\n  TreeLinkNode *next;\n}</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&gt; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\n\n&gt; Initially, all next pointers are set to NULL.\n\nFor this situation, we could use BFS algorithm which also named scan strategy.</code></pre></div>\n<p>class Solution(object):\ndef connect(self, root):\n\"\"\"\n:type root: TreeLinkNode\n:rtype: nothing\n\"\"\"\nif root is None:\nreturn None\nelse:\narray = []\nnew<em>array = []\narray.append(root)\nwhile True:\nif array[0].left is None:\nbreak\nfor item in array:\nnew</em>array.append(item.left)\nnew<em>array.append(item.right)\nfor i in range(len(new</em>array)-1):\nnew<em>array[i].next = new</em>array[i+1]\narray = new<em>array\nnew</em>array = []</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.230 [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)\n\n&gt; Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.\n\n&gt; Note:\n&gt; You may assume k is always valid, 1 ≤ k ≤ BST&#39;s total elements.\n\n&gt; Follow up:\n&gt; What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\n\nWe could use inorder search to get the kth number. The follwing is a Iterable solution using stack. Recursion is also a typical way.</code></pre></div>\n<p>class Solution(object):\ndef kthSmallest(self, root, k):\n\"\"\"\n:type root: TreeNode\n:type k: int\n:rtype: int\n\"\"\"\nl = []</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    while root:\n        l.append(root)\n        root = root.left\n    while l:\n        pop_num = l.pop()\n        if k == 1:\n            return pop_num.val\n        else:\n            k -= 1\n            tmp = pop_num.right\n            while tmp:\n                l.append(tmp)\n                tmp = tmp.left</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">For answer the follw up problem, we should modify the raw structure of BST. We could modify the original one to inorder clue tree to get the next node easily and do not waste space. A inorde head need a extra room.\n\n# No.83 [Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\n\n&gt; Given a sorted linked list, delete all duplicates such that each element appear only once.\n\nA easy problem. Just take care the bounary condition.</code></pre></div>\n<p>class Solution(object):\ndef deleteDuplicates(self, head):\n\"\"\"\n:type head: ListNode\n:rtype: ListNode\n\"\"\"\nif not head:\nreturn None\nelse:\ncursor = head\nwhile cursor.next:\nif cursor.val == cursor.next.val:\ncursor.next = cursor.next.next\nelse:\ncursor = cursor.next\nreturn head</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.70 [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)\n\n&gt; You are climbing a stair case. It takes n steps to reach to the top.\n\n&gt; Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nRecursion is the first idea in my brain. It is avalaible theoretically, but the reply is error message of recurion depth limit. So, we must using iterable way.\n\nThe solution is like Fibonacci array.</code></pre></div>\n<p>class Solution(object):\ndef climbStairs(self, n):\n\"\"\"\n:type n: int\n:rtype: int\n\"\"\"\nfirst = 1\nsecond = 2\nstart = 2\nif n == 1:\nreturn 1\nelif n == 2:\nreturn 2\nelse:\nfor i in range(2,n):\nfirst, second = second, first+second\nreturn second</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.53 [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)\n\n&gt; Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\n\n&gt; For example, given the array `[−2,1,−3,4,−1,2,1,−5,4]`,\n&gt; the contiguous subarray `[4,−1,2,1]` has the largest sum = `6`.\n\nA typical DP(dynamic programming) problem. Just Google it.</code></pre></div>\n<p>class Solution(object):\ndef maxSubArray(self, nums):\n\"\"\"\n:type nums: List[int]\n:rtype: int\n\"\"\"\nmax<em>num = max(nums)\nif max</em>num &#x3C;= 0:\nreturn max<em>num\nmax</em>of<em>all = max</em>of<em>tail = nums[0]\nfor i in range(1,len(nums)):\nmax</em>of<em>tail = max(nums[i],nums[i]+max</em>of<em>tail)\nmax</em>of<em>all = max(max</em>of<em>all, max</em>of<em>tail)\nreturn max</em>of_all</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.263 [Ugly Number](https://leetcode.com/problems/ugly-number/)\n\n&gt; Write a program to check whether a given number is an ugly number.\n\n&gt; Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.\n\n&gt; Note that 1 is typically treated as an ugly number.\n\nA easy problem and also be cautious of Boundary condition.</code></pre></div>\n<p>class Solution(object):\ndef isUgly(self, num):\n\"\"\"\n:type num: int\n:rtype: bool\n\"\"\"\nif num &#x3C;= 0:\nreturn False\nelif num in [1,2,3,5]:\nreturn True\nelif num%2 == 0:\nreturn self.isUgly(num/2)\nelif num%3 == 0:\nreturn self.isUgly(num/3)\nelif num%5 == 0:\nreturn self.isUgly(num/5)\nelse:\nreturn False</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.202 [Happy Number](https://leetcode.com/problems/happy-number/)\n\n&gt; Write an algorithm to determine if a number is &quot;happy&quot;.\n\n&gt; A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\nPython inside functions `list` and `str` can easily solve the problem while they are conbined.</code></pre></div>\n<p>class Solution(object):\ndef isHappy(self, n):\n\"\"\"\n:type n: int\n:rtype: bool\n\"\"\"\nnums = []\nwhile n not in nums:\nif n == 1:\nreturn True\nnums.append(n)\nl = list(str(n))\nn = 0\nfor i in l:\nn += (ord(i)-48)**2\nreturn False</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># No.326 [Power of Three](https://leetcode.com/problems/power-of-three/)\n\n&gt; Given an integer, write a function to determine if it is a power of three.\n\n&gt; Follow up:\n&gt; Could you do it without using any loop / recursion?\n\nIf you use loop, everything goes well.</code></pre></div>\n<p>class Solution(object):\ndef isPowerOfThree(self, n):\n\"\"\"\n:type n: int\n:rtype: bool\n\"\"\"\nif n in [1,3]:\nreturn True\ni = 3\nwhile i &#x3C; n:\ni *= 3\nif i == n:\nreturn True\nreturn False</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">There is a very tricky way to solve the problem without loop or recursion. We must face the fact that the problem is in computer rather than in math. The biggest number which is the power of 3 is specific. so if `biggest_3_power % target == 0`, then the target number is the ture answer.\n\nNo matter what is your thought, mine is WTF.\n\n# No.89 [Gray Code](https://leetcode.com/problems/gray-code/)\n\n&gt; The gray code is a binary numeral system where two successive values differ in only one bit.\n\n&gt; Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\n\n&gt; For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:\n\n&gt; ```\n00 - 0\n01 - 1\n11 - 3\n10 - 2</code></pre></div>\n<p>The key idea of this Algorithm is reduce. Once k size problem solved, we could add bit code 1 at the front of every number in the list and get a new array. Then reverse it and stick together. The new array fit Gray rule and it is the k+1 size answer.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def grayCode(self, n):\n        &quot;&quot;&quot;\n        :type n: int\n        :rtype: List[int]\n        &quot;&quot;&quot;\n        if n == 0:\n            return [0]\n        r = self.grayCode(n-1)\n        result = [x + (1 &lt;&lt; (n-1)) for x in r]\n        result.reverse()\n        r.extend(result)\n        return r</code></pre></div>\n<h1>No.62 <a href=\"https://leetcode.com/problems/unique-paths/\">Unique Paths</a></h1>\n<blockquote>\n<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>\n</blockquote>\n<blockquote>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n</blockquote>\n<blockquote>\n<p>How many possible unique paths are there?</p>\n</blockquote>\n<p>Actually a math problem. A transfomation of pascal triangle. Math solution is perfect.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def uniquePaths(self, m, n):\n        &quot;&quot;&quot;\n        :type m: int\n        :type n: int\n        :rtype: int\n        &quot;&quot;&quot;\n        return math.factorial(m+n-2)/(math.factorial(m-1)*math.factorial(n-1))</code></pre></div>\n<h1>No.153 <a href=\"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\">Find Minimum in Rotated Sorted Array</a></h1>\n<blockquote>\n<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>\n</blockquote>\n<blockquote>\n<p>(i.e., <code class=\"language-text\">0 1 2 4 5 6 7</code> might become <code class=\"language-text\">4 5 6 7 0 1 2</code>).</p>\n</blockquote>\n<blockquote>\n<p>Find the minimum element.</p>\n</blockquote>\n<blockquote>\n<p>You may assume no duplicate exists in the array.</p>\n</blockquote>\n<p>A search problem. Dichoctomizing search is the key.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def findMin(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: int\n        &quot;&quot;&quot;\n        if len(nums) == 1:\n            return nums[0]\n        l = 0\n        r = len(nums)-1\n        while l &lt; r:\n            m = (l+r)/2\n            if nums[m]&gt;nums[m+1]:\n                return nums[m+1]\n            elif nums[m] &gt; nums[l]:\n                l = m\n            else:\n                r = m\n        return nums[0]</code></pre></div>\n<h1>No.21 <a href=\"https://leetcode.com/problems/merge-two-sorted-lists/\">Merge Two Sorted Lists</a></h1>\n<blockquote>\n<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>\n</blockquote>\n<p>A NodeList typical problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        &quot;&quot;&quot;\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        &quot;&quot;&quot;\n        head = ListNode(0)\n        p = head\n        while l1 and l2:\n            if l1.val &gt; l2.val:\n                p.next = l2\n                p = p.next\n                l2 = l2.next\n            else:\n                p.next = l1\n                p = p.next\n                l1 = l1.next\n        if l1:\n            p.next = l1\n            return head.next\n        else:\n            p.next = l2\n            return head.next</code></pre></div>\n<h1>No.46 <a href=\"https://leetcode.com/problems/permutations/\">Permutations</a></h1>\n<blockquote>\n<p>Given a collection of distinct numbers, return all possible permutations.</p>\n</blockquote>\n<blockquote>\n<p>For example,\n<code class=\"language-text\">[1,2,3]</code> have the following permutations:\n<code class=\"language-text\">[1,2,3]</code>, <code class=\"language-text\">[1,3,2]</code>, <code class=\"language-text\">[2,1,3]</code>, <code class=\"language-text\">[2,3,1]</code>, <code class=\"language-text\">[3,1,2]</code>, and <code class=\"language-text\">[3,2,1]</code>.</p>\n</blockquote>\n<p>Another recursion.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def permute(self, nums):\n        &quot;&quot;&quot;\n        :type nums: List[int]\n        :rtype: List[List[int]]\n            &quot;&quot;&quot;\n        return self.sub(nums)\n\n\n    def sub(self, nums):\n        if len(nums) == 0: return [[]]\n        if len(nums) == 1: return [nums]\n        pattern = self.sub(nums[1:])\n        c = []\n        for i in xrange(len(nums)):\n            for p in pattern:\n                c.append(p[:i] + [nums[0]] + p[i:])\n        return c</code></pre></div>\n<h1>No.24 <a href=\"https://leetcode.com/problems/swap-nodes-in-pairs/\">Swap Nodes in Pairs</a></h1>\n<blockquote>\n<p>Given a linked list, swap every two adjacent nodes and return its head.</p>\n</blockquote>\n<blockquote>\n<p>For example,\nGiven <code class=\"language-text\">1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code class=\"language-text\">2-&gt;1-&gt;4-&gt;3</code>.</p>\n</blockquote>\n<blockquote>\n<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>\n</blockquote>\n<p>Take care of Boundary condition and other is only NodeList.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def swapPairs(self, head):\n        &quot;&quot;&quot;\n        :type head: ListNode\n        :rtype: ListNode\n        &quot;&quot;&quot;\n        if not head or not head.next:\n            return head\n\n        first,second = head, head.next\n        third = second.next\n        head = second\n        second.next = first\n        first.next = self.swapPairs(third)\n\n        return head</code></pre></div>\n<h1>No.216 <a href=\"https://leetcode.com/problems/combination-sum-iii/\">Combination Sum 3</a></h1>\n<blockquote>\n<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>\n</blockquote>\n<blockquote>\n<p>Ensure that numbers within the set are sorted in ascending order.</p>\n</blockquote>\n<p>DFS problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Solution(object):\n    def combinationSum3(self, k, n):\n        &quot;&quot;&quot;\n        :type k: int\n        :type n: int\n        :rtype: List[List[int]]\n        &quot;&quot;&quot;\n        def dfs(k,n,index,path,result):\n            if not n and not k:result.append(path)\n            if n&gt;0 and k&gt;0:\n                for i in range(index,10):\n                    dfs(k-1,n-i,i+1,path+[i],result)\n        result=[]\n        dfs(k,n,1,[],result)\n        return result</code></pre></div>","frontmatter":{"title":"leetcode记（持续更新中）","date":"February 29, 2016","tags":["算法","python"]}}},"pageContext":{"slug":"/leetcode记/","previous":{"fields":{"slug":"/数独的高效深度搜索解法/"},"frontmatter":{"title":"数独的高效深度搜索解法"}},"next":{"fields":{"slug":"/线性回归和梯度下降/"},"frontmatter":{"title":"线性回归和梯度下降"}}}}}