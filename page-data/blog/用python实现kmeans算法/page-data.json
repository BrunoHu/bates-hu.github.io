{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/用python实现kmeans算法/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Bates Hu"}},"markdownRemark":{"id":"c908792a-50c0-5c79-89f9-eb15c1bb1239","excerpt":"最近准备找些东西练练手，就想着实现一下一些数据处理方面的算法，一方面是可以更深刻的理解算法，二也能锻炼一下编程水平。这一次编写kmeans算法的时候就出现了很多很神奇的bug，有一些还是python这种弱类型语言所特有的，很这么人也很有意思。 K-means算法介绍 K-mea…","html":"<p>最近准备找些东西练练手，就想着实现一下一些数据处理方面的算法，一方面是可以更深刻的理解算法，二也能锻炼一下编程水平。这一次编写kmeans算法的时候就出现了很多很神奇的bug，有一些还是python这种弱类型语言所特有的，很这么人也很有意思。</p>\n<h1>K-means算法介绍</h1>\n<p>K-means算法是一种非常常用也很有效的聚类算法。这个算法能够把一个数据集以一个定义好的距离为度量划分成k个子集，而且其实简单，所以地一个用来练手。</p>\n<p>具体的内容见<a href=\"http://baike.baidu.com/link?url=hFqIy4gnmEDas7Qg6ENbKhUPmU-cpe-RxMZdYgg4M6L6jvRoALZXaWZtwnf3uKDXKFDxSwJD5laYVMMgEcGuQK\">百度百科的k-means</a>。</p>\n<h1>k-means算法流程</h1>\n<ol>\n<li>选取k个初始点作为中心点，一般是在数据集中最忌选择k个。</li>\n<li>计算数据集中所有点到中心点的距离，并选择距离最短的那个中心点，这样就把所有的点分成了k个子集。</li>\n<li>在这k个子集中选出每个自己的中点作为新的中心点。</li>\n<li>然后再迭代进行步骤2,直到这k个中心点不发生变化。这样就得到了k个中心点和k个类。</li>\n</ol>\n<h1>k-means算法的实现</h1>\n<p>下面给出k-means算法的主干部分，这个算法的<a href=\"https://github.com/Arnold-Hu/garage/blob/master/kmeans.py\">代码文件</a>在我的github的garage中。\n目前功能非常简单，只能实现点集以欧式距离为度量聚类。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def kmeans(dataset, k=2, demension=2):\n    # 初始化，dataset是要分类的数据集，demension是维度\n    empty_set = []   #制造一个[[],[],...,[]]来方便其他列表的初始化\n    for i in range(k):\n        empty_set.append([])\n    centers = []     #centers数组存放中心点\n    residation = [10]*k    #residation数组存放两次中心点向量之差\n    temp = [0] * k    #temp数组存放到每个中心点的距离\n    for i in range(k):  #把数据集的前k个点作为初始中心点\n        centers.append(dataset[i])\n    # 开始正式迭代\n    while(sum(residation)&gt;0.0001):\n        divide_set = copy.deepcopy(empty_set) #初始化子集列表\n        for i in dataset: #遍历数据集的所有数据\n            for j in range(k): #计算到每个中心点的距离\n                temp[j] = distance(i, centers[j], demension)\n            for j in range(k): #划分到所属的子类中\n                if temp[j] == min(temp):\n                    divide_set[j].append(i)\n        for j in range(k): #得到新的中心点和新旧中心点之间的差\n            residation[j] = distance(get_center(divide_set[j]), centers[j])\n            centers[j] = copy.deepcopy(get_center(divide_set[j]))\n    #算法完成，返回中心点和划分出的子类\n    return [centers,divide_set]</code></pre></div>\n<p>算法的实现方法都在注释里说明了，剩下的辅助函数如下</p>\n<ul>\n<li>\n<p>计算子类的中心点</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def get_center(dataset):\ndem = len(dataset[0])\npoint = [0.0] * dem\nfor i in dataset:\n    for j in range(dem):\n        point[j] += i[j]\nfor j in range(dem):\n    point[j] = point[j] / len(dataset)\nreturn tuple(point)</code></pre></div>\n</li>\n<li>\n<p>计算两个点之间的距离</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def distance(point1, point2, demension=2):\nsum = 0\nfor i in range(demension):\n    sum = sum + (point1[i] - point2[i])*(point1[i] - point2[i])\nreturn sum</code></pre></div>\n<p>说了这个算法很简单。。。</p>\n</li>\n</ul>\n<h1>k-means效果</h1>\n<p>同样在github/garage中有一个测试这个算法的的测试文件<a href=\"https://github.com/Arnold-Hu/garage/blob/master/test_kmeans.py\">test_kmeans.py</a>，没有按照单元测试的写法那么严格，主要是为了作出效果图顺便练练做图。\n效果图如下：\n<img src=\"http://q60sj4uk2.bkt.clouddn.com/test_kmeans.png\"></p>\n<h1>有关的bug</h1>\n<ul>\n<li>列表中的列表的复制</li>\n</ul>\n<blockquote>\n<p>python中的list变量是一个指针，如果单纯用a=b之恩那个让a和b同时指向一个list。</p>\n</blockquote>\n<p>列表的内容复制有几种方法，比如<code class=\"language-text\">a=b[:]</code>,<code class=\"language-text\">a=copy.copy(b)</code>,其中使用copy需要加载copy模块<code class=\"language-text\">import copy</code>。但是这两种方法只能复制简单列表，即列表的元素只能是基本元素，而不能是类似列表这种元素，举个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a=[1,2,[3,4]]\nb=a[:]\na[2].append(5)\nprint b</code></pre></div>\n<p>结果输出是<code class=\"language-text\">[1,2,[3,4,5]]</code>\n而要真正的复制所有内容，就需要用深拷贝。\n<code class=\"language-text\">a=copy.deepcopy(b)</code>\n这样能够迭代这把所有b中的元素拷贝到a中并且不会互相干涉。</p>\n<ul>\n<li>[ [ ] ]*k</li>\n</ul>\n<p>在算法中我用的是</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">empty_set = []\n    for i in range(k):\n        empty_set.append([])</code></pre></div>\n<p>来制造一个空的list of list.</p>\n<p>其实在一开始我用的是\n<code class=\"language-text\">empty_set = [[]]*k</code></p>\n<p>虽然看起来很简便，但是之后我发现程序有个很逗逼的bug，就是无论我往emptyset里面的那个子listappend元素，里面每个子列表都会添加同一个元素。花了很久的时间我才发现这个问题。其实这个问题和上面那个差不多，只不过更加隐蔽。这也和python很灵活有很大关系，同时提醒自己要更深入的了解原理减少再出现这种难以发现的bug的机会。</p>\n<p>虽然直接用乘法隐藏着隐患，但是用来初始化一些基本的元素里表还是很有用的，比如[0]*10就能够直接初始化一个长度为10元素值均为0的列表。</p>","frontmatter":{"title":"用python实现kmeans算法","date":"September 20, 2015","tags":["python","数据挖掘","聚类","算法"]}}},"pageContext":{"slug":"/用python实现kmeans算法/","previous":{"fields":{"slug":"/让我们来研究一下神奇的连连看/"},"frontmatter":{"title":"让我们来研究一下神奇的连连看"}},"next":{"fields":{"slug":"/一定要养成备份文件的好习惯，防止手贱/"},"frontmatter":{"title":"一定要养成备份文件的好习惯，防止手贱"}}}}}