{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2048-ai小试/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"f146fa4e-b4ae-5d49-83e5-498f6ee1b730","excerpt":"起源 最近无聊在看书的时候看到了博弈树，以及最大最小剪枝算法(alpha-beta pruning method)。脑子里想着怎么实践一下来加深对这个算法的理解，然后想到了以前刚好试过2048的ai，但是失败了，而这个算法的适用场景刚好合适，可以试试，然后就开始coding了。…","html":"<h2>起源</h2>\n<p>最近无聊在看书的时候看到了博弈树，以及最大最小剪枝算法(alpha-beta pruning method)。脑子里想着怎么实践一下来加深对这个算法的理解，然后想到了以前刚好试过2048的ai，但是失败了，而这个算法的适用场景刚好合适，可以试试，然后就开始coding了。完整的代码见<a href=\"https://github.com/Arnold-Hu/garage/blob/master/2048/ai_2048.py\">我的github</a></p>\n<h2>2048 简介</h2>\n<p>这个直接贴个游戏网址比简单的文字介绍方便多了。<a href=\"http://2048game.com\">点此试玩</a>。</p>\n<p>我们现在可以把这个抽象到代码里变成一个类。假设这个类是一个n*n的矩阵，那么这个类至少有下面的方法</p>\n<ol>\n<li>4个方向的移动，及消除</li>\n<li>检查所有可以移动的方向，没有的话判定结束</li>\n<li>在空白位置随机生成一个2/4</li>\n<li>初始化(包括拷贝和直接初始化)</li>\n</ol>\n<p>这就足以满足没有ai的玩法了。</p>\n<p>Python代码如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Matrix(object):\n    def __init__(self, matrix=None, size=4, start_unit=3, data=None, flag=0):\n        &quot;&quot;&quot;初始化，包括自动初始化，给定矩阵初始化和直接copy初始化&quot;&quot;&quot;\n        # self.ava_move = []\n        self.score = None\n        self.empty_list = set()\n        self.start_unit = start_unit\n        self.size = size\n        self.flag = flag       # 0-&gt;min 1-&gt;max\n        self.from_direction = None\n        self.ava_move = set()\n        self.dead = False\n        if data is not None:\n            self.data = np.copy(data)\n            self._refresh_empty_list()\n            self.size = len(data)\n            self.check_move()\n        elif matrix is not None:\n            self.data = np.copy(matrix.data)\n            self.empty_list = copy.copy(matrix.empty_list)\n            self.size = matrix.size\n            self.start_unit = matrix.start_unit\n            self.flag = matrix.flag\n            self.ava_move = copy.copy(matrix.ava_move)\n        else:\n            self._gen_data()\n            self.check_move()\n            # self.check_avaliable_move()\n\n    def _gen_data(self):\n        self.data = np.zeros([self.size, self.size], dtype=int)\n        map(\n            lambda x: self.empty_list.add(x),\n            [(i, j) for i in range(self.size) for j in range(self.size)]\n        )\n        sample = random.sample(self.empty_list, self.start_unit)\n        for item in sample:\n            self.data[item] = 1\n            self.empty_list.remove(item)\n\n    def push(self, direction):\n        &quot;&quot;&quot;\n        0 -&gt; move up\n        1 -&gt; move right\n        2 -&gt; move down\n        3 -&gt; move left\n        &quot;&quot;&quot;\n        for i in range(self.size):\n            if direction == 0:\n                self.data[:, i] = self._line_push(self.data[:, i], 1)\n            if direction == 1:\n                self.data[i, :] = self._line_push(self.data[i, :], 0)\n            if direction == 2:\n                self.data[:, i] = self._line_push(self.data[:, i], 0)\n            if direction == 3:\n                self.data[i, :] = self._line_push(self.data[i, :], 1)\n        self._refresh_empty_list()\n        self.flag = 1\n\n    def _line_push(self, line, direction):\n        &quot;&quot;&quot;0 -&gt; right    1 -&gt; left&quot;&quot;&quot;\n        if direction == 1:\n            zip_list = [x for x in line if x != 0]\n            for i in range(len(zip_list) - 1):\n                if zip_list[i] == zip_list[i + 1]:\n                    zip_list[i] += 1\n                    zip_list[i + 1] = 0\n            result = [x for x in zip_list if x != 0]\n            result.extend([0] * (len(line) - len(result)))\n            return np.array(result)\n        if direction == 0:\n            return self._line_push(line[::-1], 1)[::-1]\n\n    def _refresh_empty_list(self):\n        &quot;&quot;&quot;初始化或者push之后刷新空位置列表&quot;&quot;&quot;\n        self.empty_list = set()\n        map(\n            lambda pair: self.empty_list.add(pair),\n            [(i, j) for i in range(self.size) for j in range(self.size) if self.data[(i, j)] == 0]\n        )\n\n    def _gen_random(self, pair=None, number=None):\n        if number is None:\n            p = random.randint(1, 4)\n            if p == 4:\n                number = 2\n            else:\n                number = 1\n        if pair is None:\n            pair = random.sample(self.empty_list, 1)[0]\n            self.data[pair] = number\n            self.empty_list.remove(pair)\n        elif len(self.empty_list) != 0:\n            self.data[pair] = number\n            self.empty_list.remove(pair)\n\n        self.flag = 0\n\n        return self.check_move()\n\n\n    def check_move(self):\n        &quot;&quot;&quot;查询下一步可以push的方向&quot;&quot;&quot;\n        move = set()\n        for i in range(self.size):\n            for j in range(self.size):\n                if i == self.size - 1 and j == self.size - 1:\n                    pass\n                elif i == self.size - 1:\n                    self._check_right(i, j, move)\n                elif j == self.size - 1:\n                    self._check_down(i, j, move)\n                else:\n                    self._check_right(i, j, move)\n                    self._check_down(i, j, move)\n        self.ava_move = move\n        if len(move) == 0:\n            self.dead = True\n            return 0\n        else:\n            return 1\n\n    def _check_right(self, i, j, move_set):\n        left_value = self.data[i, j]\n        right_value = self.data[i, j + 1]\n        if left_value == 0 and right_value &gt; 0:\n            move_set.add(3)\n        if left_value &gt; 0 and right_value == 0:\n            move_set.add(1)\n        if left_value == right_value and left_value &gt; 0:\n            move_set.add(1)\n            move_set.add(3)\n\n    def _check_down(self, i, j, move_set):\n        up_value = self.data[i, j]\n        down_value = self.data[i + 1, j]\n        if up_value == 0 and down_value &gt; 0:\n            move_set.add(0)\n        if up_value &gt; 0 and down_value == 0:\n            move_set.add(2)\n        if up_value == down_value and up_value &gt; 0:\n            move_set.add(0)\n            move_set.add(2)\n\n    def __str__(self):\n        s = []\n        for i in range(self.size):\n            for j in range(self.size):\n                value = self.data[i, j]\n                if value == 0:\n                    s.append(&#39;*\\t&#39;)\n                else:\n                    s.append(&#39;%s\\t&#39; % 2**value)\n            s.append(&#39;\\n&#39;)\n        return &#39;&#39;.join(s)\n\n    def __repr__(self):\n        return self.info()\n\n    def info(self):\n        s = (&quot;empty list: %s\\nscore: %s\\nava move: %s\\nflag: %s\\ndirection: %s\\nmatrix data: \\n%s&quot;\n         % (self.empty_list, self.score, self.ava_move, self.flag, self.from_direction, self.__str__()))\n        return s</code></pre></div>\n<p>这个类就足以表示最基本的操作，类里面还额外维护了一些东西比如空位置列表，可移动方向之类的来方便写代码。</p>\n<h2>AI</h2>\n<h4>先来聊聊博弈树</h4>\n<p>博弈树可以看下列文章，写的已经比较详细清楚了。</p>\n<p><a href=\"http://ai.mindcont.com/Search-Based/%E5%8D%9A%E5%BC%88%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2.html\">博弈树的搜索</a></p>\n<p>简而言之就是因为每一层都有最大最小的追求，而且度大于2，所以当一个结果出来之后就知道这整个子数都会被砍掉，后面都不用算了，打到减少计算量的目的。</p>\n<p>其实，如果我们从数学上得到所有的分支结果的，但是在工程上并不能实现，尤其是像围棋这种深度爆炸的游戏，即使用全宇宙的每个原子来表示一个状态都不够 = =</p>\n<p>所以我们得另外想一个办法来处理这个问题。首先容易想到的就是我们有一个评估方法来得到当前场景的分数，那么我们就可以直搜索到一定的深度而不用一直搜索到最终状态。然后就可以愉快的用最大最小剪枝算法了。我自然只能用自己的低智商实现这个方法。</p>\n<p>这个算法的关键是如何计算这个分数，作为一个有追求的人，我当然第一个想到设计几个参数来机器学习，然而我发现跑一次得20分钟的时候我就默默放弃了T——T。最后还是拍脑袋用了一个启发式的算法来模拟人的走法。即希望这个局面在下面几个方面表现良好：</p>\n<ol>\n<li>最大的在角落</li>\n<li>每行每列都单调</li>\n<li>空位多</li>\n</ol>\n<p>反正是拍脑袋的，效果也勉强过得去，因为运算的效率比较低，试了10盘，9盘能到2048，4盘能到4096，从没到过8192。</p>\n<p>代码中计算分数部分</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    def get_score(self):\n        if self.dead:\n            return 1000000000\n        score_sum = 0\n        full = 0\n        for i in range(self.size):\n            score_sum += self._line_score(self.data[i, :])\n            score_sum += self._line_score(self.data[:, i])\n            for j in range(self.size):\n                result = 0\n                result += self._compute_unit_score2(i, j)\n                score_sum += result\n                if self.data[i, j] &gt; 0:\n                    full += 1\n        score_sum += full**2\n        return score_sum\n\n    def _compute_unit_score2(self, i, j):\n        index = 0\n        value = self.data[i, j]\n        bundary = (0, 3)\n        if i not in bundary:\n            index += 1\n        if j not in bundary:\n            index += 1\n        return value ** index\n\n    @staticmethod\n    def _line_score(line):\n        l1 = sorted(line)\n        l2 = sorted(line, reverse=True)\n        score1 = sum([abs(a - b)**2 for a, b in zip(line, l1)])\n        score2 = sum([abs(a - b)**2 for a, b in zip(line, l2)])\n        return min(score1, score2) * np.mean(line)</code></pre></div>\n<p>求ai下一步的算法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def choose_direction(node, depth=2, has_log=False):\n    # global depth_sum\n    # depth_sum += depth\n    best_direction = -1\n    min_score = 10000000000000\n    for child in node._child():\n        if has_log:\n            score = evaluate_direction_with_log(child, depth * 2 - 1)\n        else:\n            score = evaluate_direction(child, depth * 2 - 1)\n        if score &lt; min_score:\n            min_score = score\n            best_direction = child.from_direction\n    return best_direction, min_score\n\ndef evaluate_direction_by_mentcaro(node, depth=100, turns=100):\n    score = 0\n    for i in xrange(turns):\n        new_node = Matrix(node)\n        for j in range(depth):\n            new_node._gen_random()\n            if not new_node.check_move():\n                score += 1000000000\n                break\n            direction = random.sample(new_node.ava_move, 1)[0]\n            new_node.push(direction)\n        score += node.get_score()\n    return score * 1.0 / turns\n\n\ndirection_dic = {\n        0: &quot;up&quot;,\n        1: &quot;right&quot;,\n        2: &quot;down&quot;,\n        3: &quot;left&quot;\n    }\n\n\ndef run_ai():\n    n = Matrix()\n    print &quot;start&quot;\n    print n.info()\n    turn = 1\n    while not n.dead:\n        print &quot;#### turn %s ####&quot; % turn\n        turn += 1\n        print &quot;*&quot;*30\n        depth = int(math.sqrt(n.size**2 + 2 - len(n.empty_list)))\n        # depth = 2\n        # if len(n.empty_list) &lt; 5:\n        #     depth = 3\n        print &quot;search depth %s&quot; % depth\n        try:\n            direction, min_score = choose_direction(n, depth)\n        except Exception:\n            print traceback.format_exc()\n            raise\n        print &quot;#### predict direction is %s ####&quot; % direction_dic[direction]\n        print &quot;#### best score is %s ####&quot; % min_score\n        n.push(direction)\n        print n.info()\n        print &quot;#### random gen a unit ####&quot;\n        n._gen_random()\n        print n.info()\n    print &quot;done&quot;</code></pre></div>\n<h2>其他AI</h2>\n<p>其实我昨晚之后和别人讨论过，然后聊到了蒙特卡洛方法，理论上确实可以，但是我自己用这个代码实现了一下，速度太慢，没法用，python本来就慢，我自己写的也挺渣的T-T，别人动辄10w次的尝试次数完全跑不动，这种狂吃cpu的还是得用c写。</p>\n<p>然后上网看了看，还有一种表现很优异的是直接算平均的期望，只不过深度实在比较恐怖，而且因为没法剪枝，计算量非常大，这套实现也是扑街的。</p>\n<p>以后的优化方向就是用c重写一个试试看，我自己没到过16384，32768怎么也要让ai到几次 = =</p>","frontmatter":{"title":"2048 ai小试","date":"July 26, 2016","tags":["算法","ai","博弈"]}}},"pageContext":{"slug":"/2048-ai小试/","previous":{"fields":{"slug":"/logistic分类器/"},"frontmatter":{"title":"logistic分类器"}},"next":null}}}